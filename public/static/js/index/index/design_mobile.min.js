"use strict";

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);throw new Error("Cannot find module '" + o + "'");
            }var f = n[o] = { exports: {} };t[o][0].call(f.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({ 1: [function (require, module, exports) {
        (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {
            'use strict';

            var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
            } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
            };

            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
             * @license  MIT
             */

            var base64 = require('base64-js');
            var ieee754 = require('ieee754');

            exports.Buffer = Buffer;
            exports.SlowBuffer = Buffer;
            exports.INSPECT_MAX_BYTES = 50;
            Buffer.poolSize = 8192;

            /**
             * If `Buffer._useTypedArrays`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Use Object implementation (compatible down to IE6)
             */
            Buffer._useTypedArrays = function () {
                // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
                // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
                // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
                // because we need to be able to add all the node Buffer API methods. This is an issue
                // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
                try {
                    var buf = new ArrayBuffer(0);
                    var arr = new Uint8Array(buf);
                    arr.foo = function () {
                        return 42;
                    };
                    return 42 === arr.foo() && typeof arr.subarray === 'function'; // Chrome 9-10 lack `subarray`
                } catch (e) {
                    return false;
                }
            }();

            /**
             * Class: Buffer
             * =============
             *
             * The Buffer constructor returns instances of `Uint8Array` that are augmented
             * with function properties for all the node `Buffer` API functions. We use
             * `Uint8Array` so that square bracket notation works as expected -- it returns
             * a single octet.
             *
             * By augmenting the instances, we can avoid modifying the `Uint8Array`
             * prototype.
             */
            function Buffer(subject, encoding, noZero) {
                if (!(this instanceof Buffer)) return new Buffer(subject, encoding, noZero);

                var type = typeof subject === 'undefined' ? 'undefined' : _typeof(subject);

                // Workaround: node's base64 implementation allows for non-padded strings
                // while base64-js does not.
                if (encoding === 'base64' && type === 'string') {
                    subject = stringtrim(subject);
                    while (subject.length % 4 !== 0) {
                        subject = subject + '=';
                    }
                }

                // Find the length
                var length;
                if (type === 'number') length = coerce(subject);else if (type === 'string') length = Buffer.byteLength(subject, encoding);else if (type === 'object') length = coerce(subject.length); // assume that object is array-like
                else throw new Error('First argument needs to be a number, array or string.');

                var buf;
                if (Buffer._useTypedArrays) {
                    // Preferred: Return an augmented `Uint8Array` instance for best performance
                    buf = Buffer._augment(new Uint8Array(length));
                } else {
                    // Fallback: Return THIS instance of Buffer (created by `new`)
                    buf = this;
                    buf.length = length;
                    buf._isBuffer = true;
                }

                var i;
                if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
                    // Speed optimization -- use set if we're copying from a typed array
                    buf._set(subject);
                } else if (isArrayish(subject)) {
                    // Treat array-ish objects as a byte array
                    for (i = 0; i < length; i++) {
                        if (Buffer.isBuffer(subject)) buf[i] = subject.readUInt8(i);else buf[i] = subject[i];
                    }
                } else if (type === 'string') {
                    buf.write(subject, 0, encoding);
                } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
                    for (i = 0; i < length; i++) {
                        buf[i] = 0;
                    }
                }

                return buf;
            }

            // STATIC METHODS
            // ==============

            Buffer.isEncoding = function (encoding) {
                switch (String(encoding).toLowerCase()) {
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'binary':
                    case 'base64':
                    case 'raw':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return true;
                    default:
                        return false;
                }
            };

            Buffer.isBuffer = function (b) {
                return !!(b !== null && b !== undefined && b._isBuffer);
            };

            Buffer.byteLength = function (str, encoding) {
                var ret;
                str = str + '';
                switch (encoding || 'utf8') {
                    case 'hex':
                        ret = str.length / 2;
                        break;
                    case 'utf8':
                    case 'utf-8':
                        ret = utf8ToBytes(str).length;
                        break;
                    case 'ascii':
                    case 'binary':
                    case 'raw':
                        ret = str.length;
                        break;
                    case 'base64':
                        ret = base64ToBytes(str).length;
                        break;
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        ret = str.length * 2;
                        break;
                    default:
                        throw new Error('Unknown encoding');
                }
                return ret;
            };

            Buffer.concat = function (list, totalLength) {
                assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' + 'list should be an Array.');

                if (list.length === 0) {
                    return new Buffer(0);
                } else if (list.length === 1) {
                    return list[0];
                }

                var i;
                if (typeof totalLength !== 'number') {
                    totalLength = 0;
                    for (i = 0; i < list.length; i++) {
                        totalLength += list[i].length;
                    }
                }

                var buf = new Buffer(totalLength);
                var pos = 0;
                for (i = 0; i < list.length; i++) {
                    var item = list[i];
                    item.copy(buf, pos);
                    pos += item.length;
                }
                return buf;
            };

            // BUFFER INSTANCE METHODS
            // =======================

            function _hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                var remaining = buf.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = Number(length);
                    if (length > remaining) {
                        length = remaining;
                    }
                }

                // must be an even number of digits
                var strLen = string.length;
                assert(strLen % 2 === 0, 'Invalid hex string');

                if (length > strLen / 2) {
                    length = strLen / 2;
                }
                for (var i = 0; i < length; i++) {
                    var byte = parseInt(string.substr(i * 2, 2), 16);
                    assert(!isNaN(byte), 'Invalid hex string');
                    buf[offset + i] = byte;
                }
                Buffer._charsWritten = i * 2;
                return i;
            }

            function _utf8Write(buf, string, offset, length) {
                var charsWritten = Buffer._charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length);
                return charsWritten;
            }

            function _asciiWrite(buf, string, offset, length) {
                var charsWritten = Buffer._charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length);
                return charsWritten;
            }

            function _binaryWrite(buf, string, offset, length) {
                return _asciiWrite(buf, string, offset, length);
            }

            function _base64Write(buf, string, offset, length) {
                var charsWritten = Buffer._charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length);
                return charsWritten;
            }

            function _utf16leWrite(buf, string, offset, length) {
                var charsWritten = Buffer._charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length);
                return charsWritten;
            }

            Buffer.prototype.write = function (string, offset, length, encoding) {
                // Support both (string, offset, length, encoding)
                // and the legacy (string, encoding, offset, length)
                if (isFinite(offset)) {
                    if (!isFinite(length)) {
                        encoding = length;
                        length = undefined;
                    }
                } else {
                    // legacy
                    var swap = encoding;
                    encoding = offset;
                    offset = length;
                    length = swap;
                }

                offset = Number(offset) || 0;
                var remaining = this.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = Number(length);
                    if (length > remaining) {
                        length = remaining;
                    }
                }
                encoding = String(encoding || 'utf8').toLowerCase();

                var ret;
                switch (encoding) {
                    case 'hex':
                        ret = _hexWrite(this, string, offset, length);
                        break;
                    case 'utf8':
                    case 'utf-8':
                        ret = _utf8Write(this, string, offset, length);
                        break;
                    case 'ascii':
                        ret = _asciiWrite(this, string, offset, length);
                        break;
                    case 'binary':
                        ret = _binaryWrite(this, string, offset, length);
                        break;
                    case 'base64':
                        ret = _base64Write(this, string, offset, length);
                        break;
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        ret = _utf16leWrite(this, string, offset, length);
                        break;
                    default:
                        throw new Error('Unknown encoding');
                }
                return ret;
            };

            Buffer.prototype.toString = function (encoding, start, end) {
                var self = this;

                encoding = String(encoding || 'utf8').toLowerCase();
                start = Number(start) || 0;
                end = end !== undefined ? Number(end) : end = self.length;

                // Fastpath empty strings
                if (end === start) return '';

                var ret;
                switch (encoding) {
                    case 'hex':
                        ret = _hexSlice(self, start, end);
                        break;
                    case 'utf8':
                    case 'utf-8':
                        ret = _utf8Slice(self, start, end);
                        break;
                    case 'ascii':
                        ret = _asciiSlice(self, start, end);
                        break;
                    case 'binary':
                        ret = _binarySlice(self, start, end);
                        break;
                    case 'base64':
                        ret = _base64Slice(self, start, end);
                        break;
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        ret = _utf16leSlice(self, start, end);
                        break;
                    default:
                        throw new Error('Unknown encoding');
                }
                return ret;
            };

            Buffer.prototype.toJSON = function () {
                return {
                    type: 'Buffer',
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };

            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function (target, target_start, start, end) {
                var source = this;

                if (!start) start = 0;
                if (!end && end !== 0) end = this.length;
                if (!target_start) target_start = 0;

                // Copy 0 bytes; we're done
                if (end === start) return;
                if (target.length === 0 || source.length === 0) return;

                // Fatal error conditions
                assert(end >= start, 'sourceEnd < sourceStart');
                assert(target_start >= 0 && target_start < target.length, 'targetStart out of bounds');
                assert(start >= 0 && start < source.length, 'sourceStart out of bounds');
                assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds');

                // Are we oob?
                if (end > this.length) end = this.length;
                if (target.length - target_start < end - start) end = target.length - target_start + start;

                var len = end - start;

                if (len < 100 || !Buffer._useTypedArrays) {
                    for (var i = 0; i < len; i++) {
                        target[i + target_start] = this[i + start];
                    }
                } else {
                    target._set(this.subarray(start, start + len), target_start);
                }
            };

            function _base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf);
                } else {
                    return base64.fromByteArray(buf.slice(start, end));
                }
            }

            function _utf8Slice(buf, start, end) {
                var res = '';
                var tmp = '';
                end = Math.min(buf.length, end);

                for (var i = start; i < end; i++) {
                    if (buf[i] <= 0x7F) {
                        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
                        tmp = '';
                    } else {
                        tmp += '%' + buf[i].toString(16);
                    }
                }

                return res + decodeUtf8Char(tmp);
            }

            function _asciiSlice(buf, start, end) {
                var ret = '';
                end = Math.min(buf.length, end);

                for (var i = start; i < end; i++) {
                    ret += String.fromCharCode(buf[i]);
                }return ret;
            }

            function _binarySlice(buf, start, end) {
                return _asciiSlice(buf, start, end);
            }

            function _hexSlice(buf, start, end) {
                var len = buf.length;

                if (!start || start < 0) start = 0;
                if (!end || end < 0 || end > len) end = len;

                var out = '';
                for (var i = start; i < end; i++) {
                    out += toHex(buf[i]);
                }
                return out;
            }

            function _utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end);
                var res = '';
                for (var i = 0; i < bytes.length; i += 2) {
                    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                }
                return res;
            }

            Buffer.prototype.slice = function (start, end) {
                var len = this.length;
                start = clamp(start, len, 0);
                end = clamp(end, len, len);

                if (Buffer._useTypedArrays) {
                    return Buffer._augment(this.subarray(start, end));
                } else {
                    var sliceLen = end - start;
                    var newBuf = new Buffer(sliceLen, undefined, true);
                    for (var i = 0; i < sliceLen; i++) {
                        newBuf[i] = this[i + start];
                    }
                    return newBuf;
                }
            };

            // `get` will be removed in Node 0.13+
            Buffer.prototype.get = function (offset) {
                console.log('.get() is deprecated. Access using array indexes instead.');
                return this.readUInt8(offset);
            };

            // `set` will be removed in Node 0.13+
            Buffer.prototype.set = function (v, offset) {
                console.log('.set() is deprecated. Access using array indexes instead.');
                return this.writeUInt8(v, offset);
            };

            Buffer.prototype.readUInt8 = function (offset, noAssert) {
                if (!noAssert) {
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset < this.length, 'Trying to read beyond buffer length');
                }

                if (offset >= this.length) return;

                return this[offset];
            };

            function _readUInt16(buf, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');
                }

                var len = buf.length;
                if (offset >= len) return;

                var val;
                if (littleEndian) {
                    val = buf[offset];
                    if (offset + 1 < len) val |= buf[offset + 1] << 8;
                } else {
                    val = buf[offset] << 8;
                    if (offset + 1 < len) val |= buf[offset + 1];
                }
                return val;
            }

            Buffer.prototype.readUInt16LE = function (offset, noAssert) {
                return _readUInt16(this, offset, true, noAssert);
            };

            Buffer.prototype.readUInt16BE = function (offset, noAssert) {
                return _readUInt16(this, offset, false, noAssert);
            };

            function _readUInt32(buf, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');
                }

                var len = buf.length;
                if (offset >= len) return;

                var val;
                if (littleEndian) {
                    if (offset + 2 < len) val = buf[offset + 2] << 16;
                    if (offset + 1 < len) val |= buf[offset + 1] << 8;
                    val |= buf[offset];
                    if (offset + 3 < len) val = val + (buf[offset + 3] << 24 >>> 0);
                } else {
                    if (offset + 1 < len) val = buf[offset + 1] << 16;
                    if (offset + 2 < len) val |= buf[offset + 2] << 8;
                    if (offset + 3 < len) val |= buf[offset + 3];
                    val = val + (buf[offset] << 24 >>> 0);
                }
                return val;
            }

            Buffer.prototype.readUInt32LE = function (offset, noAssert) {
                return _readUInt32(this, offset, true, noAssert);
            };

            Buffer.prototype.readUInt32BE = function (offset, noAssert) {
                return _readUInt32(this, offset, false, noAssert);
            };

            Buffer.prototype.readInt8 = function (offset, noAssert) {
                if (!noAssert) {
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset < this.length, 'Trying to read beyond buffer length');
                }

                if (offset >= this.length) return;

                var neg = this[offset] & 0x80;
                if (neg) return (0xff - this[offset] + 1) * -1;else return this[offset];
            };

            function _readInt16(buf, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length');
                }

                var len = buf.length;
                if (offset >= len) return;

                var val = _readUInt16(buf, offset, littleEndian, true);
                var neg = val & 0x8000;
                if (neg) return (0xffff - val + 1) * -1;else return val;
            }

            Buffer.prototype.readInt16LE = function (offset, noAssert) {
                return _readInt16(this, offset, true, noAssert);
            };

            Buffer.prototype.readInt16BE = function (offset, noAssert) {
                return _readInt16(this, offset, false, noAssert);
            };

            function _readInt32(buf, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');
                }

                var len = buf.length;
                if (offset >= len) return;

                var val = _readUInt32(buf, offset, littleEndian, true);
                var neg = val & 0x80000000;
                if (neg) return (0xffffffff - val + 1) * -1;else return val;
            }

            Buffer.prototype.readInt32LE = function (offset, noAssert) {
                return _readInt32(this, offset, true, noAssert);
            };

            Buffer.prototype.readInt32BE = function (offset, noAssert) {
                return _readInt32(this, offset, false, noAssert);
            };

            function _readFloat(buf, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length');
                }

                return ieee754.read(buf, offset, littleEndian, 23, 4);
            }

            Buffer.prototype.readFloatLE = function (offset, noAssert) {
                return _readFloat(this, offset, true, noAssert);
            };

            Buffer.prototype.readFloatBE = function (offset, noAssert) {
                return _readFloat(this, offset, false, noAssert);
            };

            function _readDouble(buf, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length');
                }

                return ieee754.read(buf, offset, littleEndian, 52, 8);
            }

            Buffer.prototype.readDoubleLE = function (offset, noAssert) {
                return _readDouble(this, offset, true, noAssert);
            };

            Buffer.prototype.readDoubleBE = function (offset, noAssert) {
                return _readDouble(this, offset, false, noAssert);
            };

            Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
                if (!noAssert) {
                    assert(value !== undefined && value !== null, 'missing value');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset < this.length, 'trying to write beyond buffer length');
                    verifuint(value, 0xff);
                }

                if (offset >= this.length) return;

                this[offset] = value;
            };

            function _writeUInt16(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(value !== undefined && value !== null, 'missing value');
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset + 1 < buf.length, 'trying to write beyond buffer length');
                    verifuint(value, 0xffff);
                }

                var len = buf.length;
                if (offset >= len) return;

                for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
                    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
                }
            }

            Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
                _writeUInt16(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
                _writeUInt16(this, value, offset, false, noAssert);
            };

            function _writeUInt32(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(value !== undefined && value !== null, 'missing value');
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset + 3 < buf.length, 'trying to write beyond buffer length');
                    verifuint(value, 0xffffffff);
                }

                var len = buf.length;
                if (offset >= len) return;

                for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
                    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
                }
            }

            Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
                _writeUInt32(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
                _writeUInt32(this, value, offset, false, noAssert);
            };

            Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
                if (!noAssert) {
                    assert(value !== undefined && value !== null, 'missing value');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset < this.length, 'Trying to write beyond buffer length');
                    verifsint(value, 0x7f, -0x80);
                }

                if (offset >= this.length) return;

                if (value >= 0) this.writeUInt8(value, offset, noAssert);else this.writeUInt8(0xff + value + 1, offset, noAssert);
            };

            function _writeInt16(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(value !== undefined && value !== null, 'missing value');
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length');
                    verifsint(value, 0x7fff, -0x8000);
                }

                var len = buf.length;
                if (offset >= len) return;

                if (value >= 0) _writeUInt16(buf, value, offset, littleEndian, noAssert);else _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert);
            }

            Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
                _writeInt16(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
                _writeInt16(this, value, offset, false, noAssert);
            };

            function _writeInt32(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(value !== undefined && value !== null, 'missing value');
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');
                    verifsint(value, 0x7fffffff, -0x80000000);
                }

                var len = buf.length;
                if (offset >= len) return;

                if (value >= 0) _writeUInt32(buf, value, offset, littleEndian, noAssert);else _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert);
            }

            Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
                _writeInt32(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
                _writeInt32(this, value, offset, false, noAssert);
            };

            function _writeFloat(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(value !== undefined && value !== null, 'missing value');
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length');
                    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
                }

                var len = buf.length;
                if (offset >= len) return;

                ieee754.write(buf, value, offset, littleEndian, 23, 4);
            }

            Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
                _writeFloat(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
                _writeFloat(this, value, offset, false, noAssert);
            };

            function _writeDouble(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    assert(value !== undefined && value !== null, 'missing value');
                    assert(typeof littleEndian === 'boolean', 'missing or invalid endian');
                    assert(offset !== undefined && offset !== null, 'missing offset');
                    assert(offset + 7 < buf.length, 'Trying to write beyond buffer length');
                    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
                }

                var len = buf.length;
                if (offset >= len) return;

                ieee754.write(buf, value, offset, littleEndian, 52, 8);
            }

            Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
                _writeDouble(this, value, offset, true, noAssert);
            };

            Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
                _writeDouble(this, value, offset, false, noAssert);
            };

            // fill(value, start=0, end=buffer.length)
            Buffer.prototype.fill = function (value, start, end) {
                if (!value) value = 0;
                if (!start) start = 0;
                if (!end) end = this.length;

                if (typeof value === 'string') {
                    value = value.charCodeAt(0);
                }

                assert(typeof value === 'number' && !isNaN(value), 'value is not a number');
                assert(end >= start, 'end < start');

                // Fill 0 bytes; we're done
                if (end === start) return;
                if (this.length === 0) return;

                assert(start >= 0 && start < this.length, 'start out of bounds');
                assert(end >= 0 && end <= this.length, 'end out of bounds');

                for (var i = start; i < end; i++) {
                    this[i] = value;
                }
            };

            Buffer.prototype.inspect = function () {
                var out = [];
                var len = this.length;
                for (var i = 0; i < len; i++) {
                    out[i] = toHex(this[i]);
                    if (i === exports.INSPECT_MAX_BYTES) {
                        out[i + 1] = '...';
                        break;
                    }
                }
                return '<Buffer ' + out.join(' ') + '>';
            };

            /**
             * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
             * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
             */
            Buffer.prototype.toArrayBuffer = function () {
                if (typeof Uint8Array !== 'undefined') {
                    if (Buffer._useTypedArrays) {
                        return new Buffer(this).buffer;
                    } else {
                        var buf = new Uint8Array(this.length);
                        for (var i = 0, len = buf.length; i < len; i += 1) {
                            buf[i] = this[i];
                        }return buf.buffer;
                    }
                } else {
                    throw new Error('Buffer.toArrayBuffer not supported in this browser');
                }
            };

            // HELPER FUNCTIONS
            // ================

            function stringtrim(str) {
                if (str.trim) return str.trim();
                return str.replace(/^\s+|\s+$/g, '');
            }

            var BP = Buffer.prototype;

            /**
             * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
             */
            Buffer._augment = function (arr) {
                arr._isBuffer = true;

                // save reference to original Uint8Array get/set methods before overwriting
                arr._get = arr.get;
                arr._set = arr.set;

                // deprecated, will be removed in node 0.13+
                arr.get = BP.get;
                arr.set = BP.set;

                arr.write = BP.write;
                arr.toString = BP.toString;
                arr.toLocaleString = BP.toString;
                arr.toJSON = BP.toJSON;
                arr.copy = BP.copy;
                arr.slice = BP.slice;
                arr.readUInt8 = BP.readUInt8;
                arr.readUInt16LE = BP.readUInt16LE;
                arr.readUInt16BE = BP.readUInt16BE;
                arr.readUInt32LE = BP.readUInt32LE;
                arr.readUInt32BE = BP.readUInt32BE;
                arr.readInt8 = BP.readInt8;
                arr.readInt16LE = BP.readInt16LE;
                arr.readInt16BE = BP.readInt16BE;
                arr.readInt32LE = BP.readInt32LE;
                arr.readInt32BE = BP.readInt32BE;
                arr.readFloatLE = BP.readFloatLE;
                arr.readFloatBE = BP.readFloatBE;
                arr.readDoubleLE = BP.readDoubleLE;
                arr.readDoubleBE = BP.readDoubleBE;
                arr.writeUInt8 = BP.writeUInt8;
                arr.writeUInt16LE = BP.writeUInt16LE;
                arr.writeUInt16BE = BP.writeUInt16BE;
                arr.writeUInt32LE = BP.writeUInt32LE;
                arr.writeUInt32BE = BP.writeUInt32BE;
                arr.writeInt8 = BP.writeInt8;
                arr.writeInt16LE = BP.writeInt16LE;
                arr.writeInt16BE = BP.writeInt16BE;
                arr.writeInt32LE = BP.writeInt32LE;
                arr.writeInt32BE = BP.writeInt32BE;
                arr.writeFloatLE = BP.writeFloatLE;
                arr.writeFloatBE = BP.writeFloatBE;
                arr.writeDoubleLE = BP.writeDoubleLE;
                arr.writeDoubleBE = BP.writeDoubleBE;
                arr.fill = BP.fill;
                arr.inspect = BP.inspect;
                arr.toArrayBuffer = BP.toArrayBuffer;

                return arr;
            };

            // slice(start, end)
            function clamp(index, len, defaultValue) {
                if (typeof index !== 'number') return defaultValue;
                index = ~~index; // Coerce to integer.
                if (index >= len) return len;
                if (index >= 0) return index;
                index += len;
                if (index >= 0) return index;
                return 0;
            }

            function coerce(length) {
                // Coerce length to a number (possibly NaN), round up
                // in case it's fractional (e.g. 123.456) then do a
                // double negate to coerce a NaN to 0. Easy, right?
                length = ~~Math.ceil(+length);
                return length < 0 ? 0 : length;
            }

            function isArray(subject) {
                return (Array.isArray || function (subject) {
                    return Object.prototype.toString.call(subject) === '[object Array]';
                })(subject);
            }

            function isArrayish(subject) {
                return isArray(subject) || Buffer.isBuffer(subject) || subject && (typeof subject === 'undefined' ? 'undefined' : _typeof(subject)) === 'object' && typeof subject.length === 'number';
            }

            function toHex(n) {
                if (n < 16) return '0' + n.toString(16);
                return n.toString(16);
            }

            function utf8ToBytes(str) {
                var byteArray = [];
                for (var i = 0; i < str.length; i++) {
                    var b = str.charCodeAt(i);
                    if (b <= 0x7F) byteArray.push(str.charCodeAt(i));else {
                        var start = i;
                        if (b >= 0xD800 && b <= 0xDFFF) i++;
                        var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split('%');
                        for (var j = 0; j < h.length; j++) {
                            byteArray.push(parseInt(h[j], 16));
                        }
                    }
                }
                return byteArray;
            }

            function asciiToBytes(str) {
                var byteArray = [];
                for (var i = 0; i < str.length; i++) {
                    // Node's code seems to be doing this and not & 0x7F..
                    byteArray.push(str.charCodeAt(i) & 0xFF);
                }
                return byteArray;
            }

            function utf16leToBytes(str) {
                var c, hi, lo;
                var byteArray = [];
                for (var i = 0; i < str.length; i++) {
                    c = str.charCodeAt(i);
                    hi = c >> 8;
                    lo = c % 256;
                    byteArray.push(lo);
                    byteArray.push(hi);
                }

                return byteArray;
            }

            function base64ToBytes(str) {
                return base64.toByteArray(str);
            }

            function blitBuffer(src, dst, offset, length) {
                var pos;
                for (var i = 0; i < length; i++) {
                    if (i + offset >= dst.length || i >= src.length) break;
                    dst[i + offset] = src[i];
                }
                return i;
            }

            function decodeUtf8Char(str) {
                try {
                    return decodeURIComponent(str);
                } catch (err) {
                    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
                }
            }

            /*
             * We have to make sure that the value is a valid integer. This means that it
             * is non-negative. It has no fractional component and that it does not
             * exceed the maximum allowed value.
             */
            function verifuint(value, max) {
                assert(typeof value === 'number', 'cannot write a non-number as a number');
                assert(value >= 0, 'specified a negative value for writing an unsigned value');
                assert(value <= max, 'value is larger than maximum value for type');
                assert(Math.floor(value) === value, 'value has a fractional component');
            }

            function verifsint(value, max, min) {
                assert(typeof value === 'number', 'cannot write a non-number as a number');
                assert(value <= max, 'value larger than maximum allowed value');
                assert(value >= min, 'value smaller than minimum allowed value');
                assert(Math.floor(value) === value, 'value has a fractional component');
            }

            function verifIEEE754(value, max, min) {
                assert(typeof value === 'number', 'cannot write a non-number as a number');
                assert(value <= max, 'value larger than maximum allowed value');
                assert(value >= min, 'value smaller than minimum allowed value');
            }

            function assert(test, message) {
                if (!test) throw new Error(message || 'Failed assertion');
            }
        }).call(this, require("B3Wh1Y"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/..\\..\\..\\..\\node_modules\\_buffer@2.1.13@buffer\\index.js", "/..\\..\\..\\..\\node_modules\\_buffer@2.1.13@buffer");
    }, { "B3Wh1Y": 4, "base64-js": 2, "buffer": 1, "ieee754": 3 }], 2: [function (require, module, exports) {
        (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {
            'use strict';

            var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

            ;(function (exports) {
                'use strict';

                var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

                var PLUS = '+'.charCodeAt(0);
                var SLASH = '/'.charCodeAt(0);
                var NUMBER = '0'.charCodeAt(0);
                var LOWER = 'a'.charCodeAt(0);
                var UPPER = 'A'.charCodeAt(0);
                var PLUS_URL_SAFE = '-'.charCodeAt(0);
                var SLASH_URL_SAFE = '_'.charCodeAt(0);

                function decode(elt) {
                    var code = elt.charCodeAt(0);
                    if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'
                    if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'
                    if (code < NUMBER) return -1; //no match
                    if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
                    if (code < UPPER + 26) return code - UPPER;
                    if (code < LOWER + 26) return code - LOWER + 26;
                }

                function b64ToByteArray(b64) {
                    var i, j, l, tmp, placeHolders, arr;

                    if (b64.length % 4 > 0) {
                        throw new Error('Invalid string. Length must be a multiple of 4');
                    }

                    // the number of equal signs (place holders)
                    // if there are two placeholders, than the two characters before it
                    // represent one byte
                    // if there is only one, then the three characters before it represent 2 bytes
                    // this is just a cheap hack to not do indexOf twice
                    var len = b64.length;
                    placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;

                    // base64 is 4/3 + up to two characters of the original data
                    arr = new Arr(b64.length * 3 / 4 - placeHolders);

                    // if there are placeholders, only get up to the last complete 4 chars
                    l = placeHolders > 0 ? b64.length - 4 : b64.length;

                    var L = 0;

                    function push(v) {
                        arr[L++] = v;
                    }

                    for (i = 0, j = 0; i < l; i += 4, j += 3) {
                        tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
                        push((tmp & 0xFF0000) >> 16);
                        push((tmp & 0xFF00) >> 8);
                        push(tmp & 0xFF);
                    }

                    if (placeHolders === 2) {
                        tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
                        push(tmp & 0xFF);
                    } else if (placeHolders === 1) {
                        tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
                        push(tmp >> 8 & 0xFF);
                        push(tmp & 0xFF);
                    }

                    return arr;
                }

                function uint8ToBase64(uint8) {
                    var i,
                        extraBytes = uint8.length % 3,

                    // if we have 1 byte left, pad 2 bytes
                    output = "",
                        temp,
                        length;

                    function encode(num) {
                        return lookup.charAt(num);
                    }

                    function tripletToBase64(num) {
                        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
                    }

                    // go through the array every three bytes, we'll deal with trailing stuff later
                    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
                        output += tripletToBase64(temp);
                    }

                    // pad the end with zeros, but make sure to not forget the extra bytes
                    switch (extraBytes) {
                        case 1:
                            temp = uint8[uint8.length - 1];
                            output += encode(temp >> 2);
                            output += encode(temp << 4 & 0x3F);
                            output += '==';
                            break;
                        case 2:
                            temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
                            output += encode(temp >> 10);
                            output += encode(temp >> 4 & 0x3F);
                            output += encode(temp << 2 & 0x3F);
                            output += '=';
                            break;
                    }

                    return output;
                }

                exports.toByteArray = b64ToByteArray;
                exports.fromByteArray = uint8ToBase64;
            })(typeof exports === 'undefined' ? undefined.base64js = {} : exports);
        }).call(this, require("B3Wh1Y"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/..\\..\\..\\..\\node_modules\\_buffer@2.1.13@buffer\\node_modules\\base64-js\\lib\\b64.js", "/..\\..\\..\\..\\node_modules\\_buffer@2.1.13@buffer\\node_modules\\base64-js\\lib");
    }, { "B3Wh1Y": 4, "buffer": 1 }], 3: [function (require, module, exports) {
        (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {
            "use strict";

            exports.read = function (buffer, offset, isLE, mLen, nBytes) {
                var e, m;
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var nBits = -7;
                var i = isLE ? nBytes - 1 : 0;
                var d = isLE ? -1 : 1;
                var s = buffer[offset + i];

                i += d;

                e = s & (1 << -nBits) - 1;
                s >>= -nBits;
                nBits += eLen;
                for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

                m = e & (1 << -nBits) - 1;
                e >>= -nBits;
                nBits += mLen;
                for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

                if (e === 0) {
                    e = 1 - eBias;
                } else if (e === eMax) {
                    return m ? NaN : (s ? -1 : 1) * Infinity;
                } else {
                    m = m + Math.pow(2, mLen);
                    e = e - eBias;
                }
                return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            };

            exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
                var e, m, c;
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var i = isLE ? 0 : nBytes - 1;
                var d = isLE ? 1 : -1;
                var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

                value = Math.abs(value);

                if (isNaN(value) || value === Infinity) {
                    m = isNaN(value) ? 1 : 0;
                    e = eMax;
                } else {
                    e = Math.floor(Math.log(value) / Math.LN2);
                    if (value * (c = Math.pow(2, -e)) < 1) {
                        e--;
                        c *= 2;
                    }
                    if (e + eBias >= 1) {
                        value += rt / c;
                    } else {
                        value += rt * Math.pow(2, 1 - eBias);
                    }
                    if (value * c >= 2) {
                        e++;
                        c /= 2;
                    }

                    if (e + eBias >= eMax) {
                        m = 0;
                        e = eMax;
                    } else if (e + eBias >= 1) {
                        m = (value * c - 1) * Math.pow(2, mLen);
                        e = e + eBias;
                    } else {
                        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                        e = 0;
                    }
                }

                for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

                e = e << mLen | m;
                eLen += mLen;
                for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

                buffer[offset + i - d] |= s * 128;
            };
        }).call(this, require("B3Wh1Y"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/..\\..\\..\\..\\node_modules\\_buffer@2.1.13@buffer\\node_modules\\ieee754\\index.js", "/..\\..\\..\\..\\node_modules\\_buffer@2.1.13@buffer\\node_modules\\ieee754");
    }, { "B3Wh1Y": 4, "buffer": 1 }], 4: [function (require, module, exports) {
        (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {
            'use strict';

            // shim for using process in browser

            var process = module.exports = {};

            process.nextTick = function () {
                var canSetImmediate = typeof window !== 'undefined' && window.setImmediate;
                var canPost = typeof window !== 'undefined' && window.postMessage && window.addEventListener;

                if (canSetImmediate) {
                    return function (f) {
                        return window.setImmediate(f);
                    };
                }

                if (canPost) {
                    var queue = [];
                    window.addEventListener('message', function (ev) {
                        var source = ev.source;
                        if ((source === window || source === null) && ev.data === 'process-tick') {
                            ev.stopPropagation();
                            if (queue.length > 0) {
                                var fn = queue.shift();
                                fn();
                            }
                        }
                    }, true);

                    return function nextTick(fn) {
                        queue.push(fn);
                        window.postMessage('process-tick', '*');
                    };
                }

                return function nextTick(fn) {
                    setTimeout(fn, 0);
                };
            }();

            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];

            function noop() {}

            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;

            process.binding = function (name) {
                throw new Error('process.binding is not supported');
            };

            // TODO(shtylman)
            process.cwd = function () {
                return '/';
            };
            process.chdir = function (dir) {
                throw new Error('process.chdir is not supported');
            };
        }).call(this, require("B3Wh1Y"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/..\\..\\..\\..\\node_modules\\_process@0.7.0@process\\browser.js", "/..\\..\\..\\..\\node_modules\\_process@0.7.0@process");
    }, { "B3Wh1Y": 4, "buffer": 1 }], 5: [function (require, module, exports) {
        (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {
            'use strict';

            var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
            } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
            };

            /* AlloyFinger v0.1.15
             * By dntzhang
             * Github: https://github.com/AlloyTeam/AlloyFinger
             */
            ;(function () {
                function getLen(v) {
                    return Math.sqrt(v.x * v.x + v.y * v.y);
                }

                function dot(v1, v2) {
                    return v1.x * v2.x + v1.y * v2.y;
                }

                function getAngle(v1, v2) {
                    var mr = getLen(v1) * getLen(v2);
                    if (mr === 0) return 0;
                    var r = dot(v1, v2) / mr;
                    if (r > 1) r = 1;
                    return Math.acos(r);
                }

                function cross(v1, v2) {
                    return v1.x * v2.y - v2.x * v1.y;
                }

                function getRotateAngle(v1, v2) {
                    var angle = getAngle(v1, v2);
                    if (cross(v1, v2) > 0) {
                        angle *= -1;
                    }

                    return angle * 180 / Math.PI;
                }

                var HandlerAdmin = function HandlerAdmin(el) {
                    this.handlers = [];
                    this.el = el;
                };

                HandlerAdmin.prototype.add = function (handler) {
                    this.handlers.push(handler);
                };

                HandlerAdmin.prototype.del = function (handler) {
                    if (!handler) this.handlers = [];

                    for (var i = this.handlers.length; i >= 0; i--) {
                        if (this.handlers[i] === handler) {
                            this.handlers.splice(i, 1);
                        }
                    }
                };

                HandlerAdmin.prototype.dispatch = function () {
                    for (var i = 0, len = this.handlers.length; i < len; i++) {
                        var handler = this.handlers[i];
                        if (typeof handler === 'function') handler.apply(this.el, arguments);
                    }
                };

                function wrapFunc(el, handler) {
                    var handlerAdmin = new HandlerAdmin(el);
                    handlerAdmin.add(handler);

                    return handlerAdmin;
                }

                var AlloyFinger = function AlloyFinger(el, option) {

                    this.element = typeof el == 'string' ? document.querySelector(el) : el;

                    this.start = this.start.bind(this);
                    this.move = this.move.bind(this);
                    this.end = this.end.bind(this);
                    this.cancel = this.cancel.bind(this);
                    this.element.addEventListener("touchstart", this.start, false);
                    this.element.addEventListener("touchmove", this.move, false);
                    this.element.addEventListener("touchend", this.end, false);
                    this.element.addEventListener("touchcancel", this.cancel, false);

                    this.preV = { x: null, y: null };
                    this.pinchStartLen = null;
                    this.zoom = 1;
                    this.isDoubleTap = false;

                    var noop = function noop() {};

                    this.rotate = wrapFunc(this.element, option.rotate || noop);
                    this.touchStart = wrapFunc(this.element, option.touchStart || noop);
                    this.multipointStart = wrapFunc(this.element, option.multipointStart || noop);
                    this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop);
                    this.pinch = wrapFunc(this.element, option.pinch || noop);
                    this.swipe = wrapFunc(this.element, option.swipe || noop);
                    this.tap = wrapFunc(this.element, option.tap || noop);
                    this.doubleTap = wrapFunc(this.element, option.doubleTap || noop);
                    this.longTap = wrapFunc(this.element, option.longTap || noop);
                    this.singleTap = wrapFunc(this.element, option.singleTap || noop);
                    this.pressMove = wrapFunc(this.element, option.pressMove || noop);
                    this.twoFingerPressMove = wrapFunc(this.element, option.twoFingerPressMove || noop);
                    this.touchMove = wrapFunc(this.element, option.touchMove || noop);
                    this.touchEnd = wrapFunc(this.element, option.touchEnd || noop);
                    this.touchCancel = wrapFunc(this.element, option.touchCancel || noop);

                    this._cancelAllHandler = this.cancelAll.bind(this);

                    window.addEventListener('scroll', this._cancelAllHandler);

                    this.delta = null;
                    this.last = null;
                    this.now = null;
                    this.tapTimeout = null;
                    this.singleTapTimeout = null;
                    this.longTapTimeout = null;
                    this.swipeTimeout = null;
                    this.x1 = this.x2 = this.y1 = this.y2 = null;
                    this.preTapPosition = { x: null, y: null };
                };

                AlloyFinger.prototype = {
                    start: function start(evt) {
                        if (!evt.touches) return;
                        this.now = Date.now();
                        this.x1 = evt.touches[0].pageX;
                        this.y1 = evt.touches[0].pageY;
                        this.delta = this.now - (this.last || this.now);
                        this.touchStart.dispatch(evt, this.element);
                        if (this.preTapPosition.x !== null) {
                            this.isDoubleTap = this.delta > 0 && this.delta <= 250 && Math.abs(this.preTapPosition.x - this.x1) < 30 && Math.abs(this.preTapPosition.y - this.y1) < 30;
                            if (this.isDoubleTap) clearTimeout(this.singleTapTimeout);
                        }
                        this.preTapPosition.x = this.x1;
                        this.preTapPosition.y = this.y1;
                        this.last = this.now;
                        var preV = this.preV,
                            len = evt.touches.length;
                        if (len > 1) {
                            this._cancelLongTap();
                            this._cancelSingleTap();
                            var v = { x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1 };
                            preV.x = v.x;
                            preV.y = v.y;
                            this.pinchStartLen = getLen(preV);
                            this.multipointStart.dispatch(evt, this.element);
                        }
                        this._preventTap = false;
                        this.longTapTimeout = setTimeout(function () {
                            this.longTap.dispatch(evt, this.element);
                            this._preventTap = true;
                        }.bind(this), 750);
                    },
                    move: function move(evt) {
                        if (!evt.touches) return;
                        var preV = this.preV,
                            len = evt.touches.length,
                            currentX = evt.touches[0].pageX,
                            currentY = evt.touches[0].pageY;
                        this.isDoubleTap = false;
                        if (len > 1) {
                            var sCurrentX = evt.touches[1].pageX,
                                sCurrentY = evt.touches[1].pageY;
                            var v = { x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY };

                            if (preV.x !== null) {
                                if (this.pinchStartLen > 0) {
                                    evt.zoom = getLen(v) / this.pinchStartLen;
                                    this.pinch.dispatch(evt, this.element);
                                }

                                evt.angle = getRotateAngle(v, preV);
                                this.rotate.dispatch(evt, this.element);
                            }
                            preV.x = v.x;
                            preV.y = v.y;

                            if (this.x2 !== null && this.sx2 !== null) {
                                evt.deltaX = (currentX - this.x2 + sCurrentX - this.sx2) / 2;
                                evt.deltaY = (currentY - this.y2 + sCurrentY - this.sy2) / 2;
                            } else {
                                evt.deltaX = 0;
                                evt.deltaY = 0;
                            }
                            this.twoFingerPressMove.dispatch(evt, this.element);

                            this.sx2 = sCurrentX;
                            this.sy2 = sCurrentY;
                        } else {
                            if (this.x2 !== null) {
                                evt.deltaX = currentX - this.x2;
                                evt.deltaY = currentY - this.y2;

                                //move事件中添加对当前触摸点到初始触摸点的判断，
                                //如果曾经大于过某个距离(比如10),就认为是移动到某个地方又移回来，应该不再触发tap事件才对。
                                var movedX = Math.abs(this.x1 - this.x2),
                                    movedY = Math.abs(this.y1 - this.y2);

                                if (movedX > 10 || movedY > 10) {
                                    this._preventTap = true;
                                }
                            } else {
                                evt.deltaX = 0;
                                evt.deltaY = 0;
                            }

                            this.pressMove.dispatch(evt, this.element);
                        }

                        this.touchMove.dispatch(evt, this.element);

                        this._cancelLongTap();
                        this.x2 = currentX;
                        this.y2 = currentY;

                        if (len > 1) {
                            evt.preventDefault();
                        }
                    },
                    end: function end(evt) {
                        if (!evt.changedTouches) return;
                        this._cancelLongTap();
                        var self = this;
                        if (evt.touches.length < 2) {
                            this.multipointEnd.dispatch(evt, this.element);
                            this.sx2 = this.sy2 = null;
                        }

                        //swipe
                        if (this.x2 && Math.abs(this.x1 - this.x2) > 30 || this.y2 && Math.abs(this.y1 - this.y2) > 30) {
                            evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);
                            this.swipeTimeout = setTimeout(function () {
                                self.swipe.dispatch(evt, self.element);
                            }, 0);
                        } else {
                            this.tapTimeout = setTimeout(function () {
                                if (!self._preventTap) {
                                    self.tap.dispatch(evt, self.element);
                                }
                                // trigger double tap immediately
                                if (self.isDoubleTap) {
                                    self.doubleTap.dispatch(evt, self.element);
                                    self.isDoubleTap = false;
                                }
                            }, 0);

                            if (!self.isDoubleTap) {
                                self.singleTapTimeout = setTimeout(function () {
                                    self.singleTap.dispatch(evt, self.element);
                                }, 250);
                            }
                        }

                        this.touchEnd.dispatch(evt, this.element);

                        this.preV.x = 0;
                        this.preV.y = 0;
                        this.zoom = 1;
                        this.pinchStartLen = null;
                        this.x1 = this.x2 = this.y1 = this.y2 = null;
                    },
                    cancelAll: function cancelAll() {
                        this._preventTap = true;
                        clearTimeout(this.singleTapTimeout);
                        clearTimeout(this.tapTimeout);
                        clearTimeout(this.longTapTimeout);
                        clearTimeout(this.swipeTimeout);
                    },
                    cancel: function cancel(evt) {
                        this.cancelAll();
                        this.touchCancel.dispatch(evt, this.element);
                    },
                    _cancelLongTap: function _cancelLongTap() {
                        clearTimeout(this.longTapTimeout);
                    },
                    _cancelSingleTap: function _cancelSingleTap() {
                        clearTimeout(this.singleTapTimeout);
                    },
                    _swipeDirection: function _swipeDirection(x1, x2, y1, y2) {
                        return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? 'Left' : 'Right' : y1 - y2 > 0 ? 'Up' : 'Down';
                    },

                    on: function on(evt, handler) {
                        if (this[evt]) {
                            this[evt].add(handler);
                        }
                    },

                    off: function off(evt, handler) {
                        if (this[evt]) {
                            this[evt].del(handler);
                        }
                    },

                    destroy: function destroy() {
                        if (this.singleTapTimeout) clearTimeout(this.singleTapTimeout);
                        if (this.tapTimeout) clearTimeout(this.tapTimeout);
                        if (this.longTapTimeout) clearTimeout(this.longTapTimeout);
                        if (this.swipeTimeout) clearTimeout(this.swipeTimeout);

                        this.element.removeEventListener("touchstart", this.start);
                        this.element.removeEventListener("touchmove", this.move);
                        this.element.removeEventListener("touchend", this.end);
                        this.element.removeEventListener("touchcancel", this.cancel);

                        this.rotate.del();
                        this.touchStart.del();
                        this.multipointStart.del();
                        this.multipointEnd.del();
                        this.pinch.del();
                        this.swipe.del();
                        this.tap.del();
                        this.doubleTap.del();
                        this.longTap.del();
                        this.singleTap.del();
                        this.pressMove.del();
                        this.twoFingerPressMove.del();
                        this.touchMove.del();
                        this.touchEnd.del();
                        this.touchCancel.del();

                        this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null;

                        window.removeEventListener('scroll', this._cancelAllHandler);
                        return null;
                    }
                };

                if (typeof module !== 'undefined' && (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
                    module.exports = AlloyFinger;
                } else {
                    window.AlloyFinger = AlloyFinger;
                }
            })();
        }).call(this, require("B3Wh1Y"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/..\\..\\..\\..\\node_modules\\alloyfinger\\alloy_finger.js", "/..\\..\\..\\..\\node_modules\\alloyfinger");
    }, { "B3Wh1Y": 4, "buffer": 1 }], 6: [function (require, module, exports) {
        (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {
            "use strict";

            /* transformjs
            * By dntzhang
            * Github: https://github.com/AlloyTeam/AlloyTouch/tree/master/transformjs
            */

            ;(function () {

                var Matrix3D = function Matrix3D(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                    this.elements = window.Float32Array ? new Float32Array(16) : [];
                    var te = this.elements;
                    te[0] = n11 !== undefined ? n11 : 1;te[4] = n12 || 0;te[8] = n13 || 0;te[12] = n14 || 0;
                    te[1] = n21 || 0;te[5] = n22 !== undefined ? n22 : 1;te[9] = n23 || 0;te[13] = n24 || 0;
                    te[2] = n31 || 0;te[6] = n32 || 0;te[10] = n33 !== undefined ? n33 : 1;te[14] = n34 || 0;
                    te[3] = n41 || 0;te[7] = n42 || 0;te[11] = n43 || 0;te[15] = n44 !== undefined ? n44 : 1;
                };

                Matrix3D.DEG_TO_RAD = Math.PI / 180;

                Matrix3D.prototype = {
                    set: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                        var te = this.elements;
                        te[0] = n11;te[4] = n12;te[8] = n13;te[12] = n14;
                        te[1] = n21;te[5] = n22;te[9] = n23;te[13] = n24;
                        te[2] = n31;te[6] = n32;te[10] = n33;te[14] = n34;
                        te[3] = n41;te[7] = n42;te[11] = n43;te[15] = n44;
                        return this;
                    },
                    identity: function identity() {
                        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                        return this;
                    },
                    multiplyMatrices: function multiplyMatrices(a, be) {

                        var ae = a.elements;
                        var te = this.elements;
                        var a11 = ae[0],
                            a12 = ae[4],
                            a13 = ae[8],
                            a14 = ae[12];
                        var a21 = ae[1],
                            a22 = ae[5],
                            a23 = ae[9],
                            a24 = ae[13];
                        var a31 = ae[2],
                            a32 = ae[6],
                            a33 = ae[10],
                            a34 = ae[14];
                        var a41 = ae[3],
                            a42 = ae[7],
                            a43 = ae[11],
                            a44 = ae[15];

                        var b11 = be[0],
                            b12 = be[1],
                            b13 = be[2],
                            b14 = be[3];
                        var b21 = be[4],
                            b22 = be[5],
                            b23 = be[6],
                            b24 = be[7];
                        var b31 = be[8],
                            b32 = be[9],
                            b33 = be[10],
                            b34 = be[11];
                        var b41 = be[12],
                            b42 = be[13],
                            b43 = be[14],
                            b44 = be[15];

                        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

                        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

                        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

                        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

                        return this;
                    },
                    // 解决角度为90的整数倍导致Math.cos得到极小的数，其实是0。导致不渲染
                    _rounded: function _rounded(value, i) {
                        i = Math.pow(10, i || 15);
                        // default
                        return Math.round(value * i) / i;
                    },
                    appendTransform: function appendTransform(x, y, z, scaleX, scaleY, scaleZ, rotateX, rotateY, rotateZ, skewX, skewY, originX, originY, originZ) {

                        var rx = rotateX * Matrix3D.DEG_TO_RAD;
                        var cosx = this._rounded(Math.cos(rx));
                        var sinx = this._rounded(Math.sin(rx));
                        var ry = rotateY * Matrix3D.DEG_TO_RAD;
                        var cosy = this._rounded(Math.cos(ry));
                        var siny = this._rounded(Math.sin(ry));
                        var rz = rotateZ * Matrix3D.DEG_TO_RAD;
                        var cosz = this._rounded(Math.cos(rz * -1));
                        var sinz = this._rounded(Math.sin(rz * -1));

                        this.multiplyMatrices(this, [1, 0, 0, x, 0, cosx, sinx, y, 0, -sinx, cosx, z, 0, 0, 0, 1]);

                        this.multiplyMatrices(this, [cosy, 0, siny, 0, 0, 1, 0, 0, -siny, 0, cosy, 0, 0, 0, 0, 1]);

                        this.multiplyMatrices(this, [cosz * scaleX, sinz * scaleY, 0, 0, -sinz * scaleX, cosz * scaleY, 0, 0, 0, 0, 1 * scaleZ, 0, 0, 0, 0, 1]);

                        if (skewX || skewY) {
                            this.multiplyMatrices(this, [this._rounded(Math.cos(skewX * Matrix3D.DEG_TO_RAD)), this._rounded(Math.sin(skewX * Matrix3D.DEG_TO_RAD)), 0, 0, -1 * this._rounded(Math.sin(skewY * Matrix3D.DEG_TO_RAD)), this._rounded(Math.cos(skewY * Matrix3D.DEG_TO_RAD)), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
                        }

                        if (originX || originY || originZ) {
                            this.elements[12] -= originX * this.elements[0] + originY * this.elements[4] + originZ * this.elements[8];
                            this.elements[13] -= originX * this.elements[1] + originY * this.elements[5] + originZ * this.elements[9];
                            this.elements[14] -= originX * this.elements[2] + originY * this.elements[6] + originZ * this.elements[10];
                        }
                        return this;
                    }
                };

                function observe(target, props, callback) {
                    for (var i = 0, len = props.length; i < len; i++) {
                        var prop = props[i];
                        watch(target, prop, callback);
                    }
                }

                function watch(target, prop, callback) {
                    Object.defineProperty(target, prop, {
                        get: function get() {
                            return this["__" + prop];
                        },
                        set: function set(value) {
                            if (value !== this["__" + prop]) {
                                this["__" + prop] = value;
                                callback();
                            }
                        }
                    });
                }

                window.Transform = function (element, notPerspective) {

                    observe(element, ["translateX", "translateY", "translateZ", "scaleX", "scaleY", "scaleZ", "rotateX", "rotateY", "rotateZ", "skewX", "skewY", "originX", "originY", "originZ"], function () {
                        var mtx = element.matrix3D.identity().appendTransform(element.translateX, element.translateY, element.translateZ, element.scaleX, element.scaleY, element.scaleZ, element.rotateX, element.rotateY, element.rotateZ, element.skewX, element.skewY, element.originX, element.originY, element.originZ);
                        element.style.transform = element.style.msTransform = element.style.OTransform = element.style.MozTransform = element.style.webkitTransform = (notPerspective ? "" : "perspective(" + (element.perspective === undefined ? 500 : element.perspective) + "px) ") + "matrix3d(" + Array.prototype.slice.call(mtx.elements).join(",") + ")";
                    });

                    element.matrix3D = new Matrix3D();

                    if (!notPerspective) {
                        observe(element, ["perspective"], function () {
                            element.style.transform = element.style.msTransform = element.style.OTransform = element.style.MozTransform = element.style.webkitTransform = "perspective(" + element.perspective + "px) matrix3d(" + Array.prototype.slice.call(element.matrix3D.elements).join(",") + ")";
                        });
                        element.perspective = 500;
                    }

                    element.scaleX = element.scaleY = element.scaleZ = 1;
                    //由于image自带了x\y\z，所有加上translate前缀
                    element.translateX = element.translateY = element.translateZ = element.rotateX = element.rotateY = element.rotateZ = element.skewX = element.skewY = element.originX = element.originY = element.originZ = 0;
                };
            })();
        }).call(this, require("B3Wh1Y"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/..\\..\\..\\..\\node_modules\\alloyfinger\\transformjs\\transform.js", "/..\\..\\..\\..\\node_modules\\alloyfinger\\transformjs");
    }, { "B3Wh1Y": 4, "buffer": 1 }], 7: [function (require, module, exports) {
        (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {
            'use strict';

            var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
            } : function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
            };

            /* AlloyFinger v0.1.0 for Vue
             * By june01
             * Github: https://github.com/AlloyTeam/AlloyFinger
             */

            ;(function () {

                var AlloyFingerPlugin = {
                    install: function install(Vue, options) {
                        options = options || {};
                        var AlloyFinger = window.AlloyFinger || options.AlloyFinger;
                        var isVue2 = !!(Vue.version.substr(0, 1) == 2);

                        if (!AlloyFinger) {
                            throw new Error('you need include the AlloyFinger!');
                        }

                        var EVENTMAP = {
                            'touch-start': 'touchStart',
                            'touch-move': 'touchMove',
                            'touch-end': 'touchEnd',
                            'touch-cancel': 'touchCancel',
                            'multipoint-start': 'multipointStart',
                            'multipoint-end': 'multipointEnd',
                            'tap': 'tap',
                            'double-tap': 'doubleTap',
                            'long-tap': 'longTap',
                            'single-tap': 'singleTap',
                            'rotate': 'rotate',
                            'pinch': 'pinch',
                            'press-move': 'pressMove',
                            'swipe': 'swipe'
                        };

                        var CACHE = [];

                        var directiveOpts = {};

                        // get the index for elem in CACHE
                        var getElemCacheIndex = function getElemCacheIndex(elem) {
                            for (var i = 0, len = CACHE.length; i < len; i++) {
                                if (CACHE[i].elem === elem) {
                                    return i;
                                }
                            }

                            return null;
                        };

                        // do on or off handler
                        var doOnOrOff = function doOnOrOff(cacheObj, options) {
                            var eventName = options.eventName;
                            var elem = options.elem;
                            var func = options.func;
                            var oldFunc = options.oldFunc;

                            if (cacheObj && cacheObj.alloyFinger) {
                                if (cacheObj.alloyFinger.off && oldFunc) cacheObj.alloyFinger.off(eventName, oldFunc);
                                if (cacheObj.alloyFinger.on && func) cacheObj.alloyFinger.on(eventName, func);
                            } else {
                                options = {};
                                options[eventName] = func;

                                CACHE.push({
                                    elem: elem,
                                    alloyFinger: new AlloyFinger(elem, options)
                                });
                            }
                        };

                        // for bind the event
                        var doBindEvent = function doBindEvent(elem, binding) {
                            var func = binding.value;
                            var oldFunc = binding.oldValue;
                            var eventName = binding.arg;

                            eventName = EVENTMAP[eventName];

                            var cacheObj = CACHE[getElemCacheIndex(elem)];

                            doOnOrOff(cacheObj, {
                                elem: elem,
                                func: func,
                                oldFunc: oldFunc,
                                eventName: eventName
                            });
                        };

                        // for bind the event
                        var doUnbindEvent = function doUnbindEvent(elem) {
                            var index = getElemCacheIndex(elem);

                            if (!isNaN(index)) {
                                var delArr = CACHE.splice(index, 1);
                                if (delArr.length && delArr[0] && delArr[0].alloyFinger.destroy) {
                                    delArr[0].alloyFinger.destroy();
                                }
                            }
                        };

                        if (isVue2) {
                            directiveOpts = {
                                bind: doBindEvent,
                                update: doBindEvent,
                                unbind: doUnbindEvent
                            };
                        } else {
                            // vue1.xx
                            directiveOpts = {
                                update: function update(newValue, oldValue) {
                                    var binding = {
                                        value: newValue,
                                        oldValue: oldValue,
                                        arg: this.arg
                                    };

                                    var elem = this.el;

                                    doBindEvent.call(this, elem, binding);
                                },
                                unbind: function unbind() {
                                    var elem = this.el;

                                    doUnbindEvent.call(this, elem);
                                }
                            };
                        }

                        // definition
                        Vue.directive('finger', directiveOpts);
                    }

                    // export
                };if (typeof module !== 'undefined' && (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
                    module.exports = AlloyFingerPlugin;
                } else {
                    window.AlloyFingerVue = AlloyFingerPlugin;
                }
            })();
        }).call(this, require("B3Wh1Y"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/..\\..\\..\\..\\node_modules\\alloyfinger\\vue\\alloy_finger.vue.js", "/..\\..\\..\\..\\node_modules\\alloyfinger\\vue");
    }, { "B3Wh1Y": 4, "buffer": 1 }], 8: [function (require, module, exports) {
        (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, __filename, __dirname) {
            'use strict';

            var _alloy_finger = require('alloyfinger/alloy_finger');

            var _alloy_finger2 = _interopRequireDefault(_alloy_finger);

            var _alloy_finger3 = require('alloyfinger/vue/alloy_finger.vue');

            var _alloy_finger4 = _interopRequireDefault(_alloy_finger3);

            require('alloyfinger/transformjs/transform.js');

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
            }

            var uploader = ''; // 手势库

            // import VConsole from 'vconsole/dist/vconsole.min.js'
            Vue.use(_alloy_finger4.default, {
                AlloyFinger: _alloy_finger2.default
            });

            // Vue.use(Transform)
            var vm = new Vue({
                el: '.mobile-app',
                data: {
                    curTab: '',
                    index: [],
                    creatingOrderFlag: 0,
                    buyText: "立即购买",

                    // sizeName: [],
                    sizeNames: ['S', 'M', 'L', 'XL', 'XXL'],
                    colorId: [],
                    uploadImagePath: '',
                    stock: { //存货标记 
                        sex: [],
                        color: [],
                        style: [],
                        material: [],
                        cloth_size: [],
                        level: []
                    },
                    uploadText: '点击上传图片',
                    sizeNum: [],
                    imageName: '',
                    styleTypeList: {},
                    showTag: false,
                    goodsNum: 0,
                    side: 'front', //正反面
                    isMiniProgram: false,
                    screenWidth: document.body.clientWidth,
                    upload: '/uploads/',
                    imageUrl: '',
                    styleUrl: '',
                    baseImage: 0,
                    designData: {
                        style: {
                            sex: 0,
                            material: 0,
                            color: 0,
                            style: 0,
                            size: '',
                            level: 0
                        },
                        image: {
                            type: 'system',
                            label: '',
                            image_name: '',
                            image_id: '',
                            image_path: ''
                        },
                        transform: {
                            locationW: 0, // 图案所在区域 宽高
                            locationH: 0,
                            deg: 0,
                            scale: 1, // 图案缩放比例
                            translateX: 0, // 中心偏移距离
                            translateY: 0
                        },
                        template_id: ''
                    },
                    recommendLabel: ["最新", "人物", "插画", "植物", '动物', '星座', "卡通", '其他'],
                    styleRemain: "",
                    styleSelect: [], //款式选择
                    totalGoodsNum: [],
                    styleShow: true,
                    imageShow: false,
                    checkShow: false,
                    checkoutInfo: {
                        curPrice: 59,
                        number: 1
                    },
                    styleType: 1,
                    imageList: [],
                    imageUrlInfo: [],
                    imagePriceInfo: [],
                    imageNameInfo: [],
                    stylePrice: 0, //售价
                    costPrice: 0, //原价
                    showcost: false, // 是否显示原价，false不显示
                    // totalPrice: 0,
                    imagePrice: 0,
                    imageTarget: '', // 存放选中的图案
                    imageIndex: 'a', // 存放选中图案索引值
                    sizeList: [{
                        name: 'S',
                        type: 's'
                    }, {
                        name: 'M',
                        type: 'm'
                    }, {
                        name: 'L',
                        type: 'l'
                    }, {
                        name: 'XL',
                        type: 'xl'
                    }, {
                        name: 'XXL',
                        type: 'xxl'
                    }],
                    imgInitW: 0,
                    imgInitH: 0,
                    imageEditTag: false, // 显示可编辑样式
                    main: true,
                    page: 1,
                    pageNum: 5,
                    maxNum: 0,
                    maxPage: 1,
                    finished: true,
                    imageMoveTag: false,
                    creatingDesignId: 0,
                    design_id: '' // 测试模板
                },
                created: function created() {
                    var designUrl = window.location.search; //获取url中"?"符后的字串
                    var arr = designUrl.substr(1).split("&");
                    if (arr[1]) {
                        var arr1 = arr[1].split('=');
                        this.design_id = Number(arr1[1]);
                        this.designData.template_id = Number(arr1[1]);
                    } else {
                        this.creatingDesignId = 1;
                    }
                    this.getTagList();
                },
                mounted: function mounted() {
                    var _this = this;

                    // var vConsole = new VConsole();
                    var that = this;
                    this.styleType = document.getElementById("style-type").value;
                    this.getStyleParam();
                    axios.get('/index/index/get_style_remain', {
                        params: {
                            type: this.styleType
                        }
                    }).then(function (res) {
                        //库存
                        _this.styleSelect = res.data;
                        _this.styleSelect.forEach(function (el) {
                            _this.stock.sex.push(el.sex);
                        });
                        vm.judgeStyle();
                        _this.index = [];
                        var len = 4,
                            pos = 0,
                            exist = [];
                        while (pos < len) {
                            pos = _this.sizeNum.indexOf(0, pos);
                            if (pos === -1) {
                                //未找到就退出循环完成搜索
                                break;
                            }
                            _this.index.push(pos); //找到就存储索引
                            pos += 1; //并从下个位置开始搜索
                        }
                        _this.index.forEach(function (el, index) {
                            _this.stock.cloth_size.push(_this.sizeNames[el]);
                        });
                        _this.sizeList.forEach(function (el, index) {
                            if (_this.stock.cloth_size.indexOf(el.name) == -1) {
                                exist.push(index);
                            }
                        });
                        _this.designData.style.size = _this.sizeNames[exist[0]];
                    });
                    this.initUpload();
                    this.$nextTick(function () {
                        var that = _this;
                        var scrolls = document.querySelector('.image-style-container');
                        _this.initTransform();
                        _this.$refs.mainContent.addEventListener('scroll', function () {
                            var scrollTop = scrolls.scrollTop;
                            var offsetHeight = scrolls.offsetHeight;
                            var scrollHeight = scrolls.scrollHeight;

                            if (that.finished && offsetHeight + scrollTop - scrollHeight >= 0) {
                                that.finished = false;
                                that.loadMoreImage();
                            }
                        });
                    });
                    document.getElementById('baseImage').onload = function () {
                        if (that.design_id != '') {
                            that.getDesignTemplate();
                        }
                    };
                    // const    payParam = {
                    //     appId: "wx71c79285ca40ccfd",
                    //     nonceStr: "5K8264ILTKCH16CQ2502SI8ZNMTM67VS",
                    //     package: "prepay_id=wx2017033010242291fcfe0db70013231072",
                    //     signType: "MD5",
                    //     timeStamp: "1490840662",
                    //     paySign:"BB2B9BD3F2F8A1CB270C6ACE3D7BDB9"
                    // };
                    // // alert(payParam);
                    // this.navigateToMiniProgram(JSON.stringify(payParam));
                },

                methods: {
                    initUpload: function initUpload() {
                        var that = this;
                        //实例化一个plupload上传对象
                        uploader = new plupload.Uploader({
                            browse_button: 'upload-btn', //触发文件选择对话框的按钮，为那个元素id
                            url: '/index/index/upload', //服务器端的上传页面地址
                            filters: {
                                mime_types: [{
                                    title: "image files",
                                    extensions: "jpg,gif,png,jpeg"
                                }],
                                max_file_size: '5mb'
                            },
                            flash_swf_url: '/static/lib/plupload/Moxie.swf', //swf文件，当需要使用swf方式进行上传时需要配置该参数
                            silverlight_xap_url: '/static/lib/plupload/Moxie.xap' //silverlight文件，当需要使用silverlight方式进行上传时需要配置该参数
                        });

                        //在实例对象上调用init()方法进行初始化
                        uploader.init();

                        //绑定各种事件，并在事件监听函数中做你想做的事
                        uploader.bind('FilesAdded', function (uploader, files) {
                            uploader.start();
                        });

                        uploader.bind('UploadProgress', function (uploader, file) {
                            vm.uploadText = '上传中(' + uploader.percent + '%)';

                            //每个事件监听函数都会传入一些很有用的参数，
                            //我们可以利用这些参数提供的信息来做比如更新UI，提示上传进度等操作
                        });
                        uploader.bind('FileUploaded', function (uploader, file, callback) {
                            var data = JSON.parse(callback.response);
                            vm.uploadText = '重新上传图片';

                            if (data['code'] == '200') {

                                vm.imageEditTag = true;
                                vm.uploadImagePath = data.path;
                                vm.imageUrl = '/uploads/' + data.path;
                                vm.showTag = true;
                                vm.curTab = '';
                                vm.imageShow = !this.imageShow;
                                var target = event.target;
                                var clothImage = vm.$refs.baseImage;
                                var a = document.getElementsByClassName('shirt-bg')[0];
                                var w = clothImage.width;
                                var addImage = document.getElementsByClassName('addImage')[0];
                                var tips = document.getElementsByClassName('tips')[0];
                                addImage.style.width = w / 2.375 + 'px';
                                addImage.style.height = w / 1.75 + 'px';
                                vm.designData.transform.locationW = w / 2.375 + 'px';
                                vm.designData.transform.locationH = w / 1.75 + 'px';
                                addImage.style.left = w / 4 + w / 20 + clothImage.offsetLeft + 'px';
                                addImage.style.top = w / 4 + 'px';
                                tips.style.top = w / 4 + w / 1.75 + 10 + 'px';
                                tips.style.left = w / 4 + w / 20 + clothImage.offsetLeft + 'px';
                                tips.style.width = w / 2.375 + 'px';
                                vm.imagePrice = 0;
                                vm.designData.image.image_id = '';
                                vm.designData.image.image_path = vm.uploadImagePath;
                                vm.designData.image.image_name = '自定义';
                                vm.imageName = '自定义';
                                vm.$refs.addImage.onload = function () {
                                    vm.designData.transform.scale = document.getElementById('img').width / document.getElementById('img').naturalWidth;
                                };
                            } else {
                                alert(data['message']);
                            }
                            //每个事件监听函数都会传入一些很有用的参数，
                            //我们可以利用这些参数提供的信息来做比如更新UI，提示上传进度等操作
                        });
                    },
                    changeSide: function changeSide(val) {
                        //正反面
                        this.side = val;
                    },
                    initImgLocate: function initImgLocate() {
                        // 初始化图案位置
                        var clothImage = this.$refs.baseImage;
                        var w = clothImage.width;
                        var addImage = document.getElementsByClassName('addImage')[0];
                        var tips = document.getElementsByClassName('tips')[0];
                        addImage.style.width = w / 2.375 + 'px';
                        addImage.style.height = w / 1.75 + 'px';
                        addImage.style.left = w / 4 + w / 20 + clothImage.offsetLeft + 'px';
                        addImage.style.top = w / 4 + 'px';
                        tips.style.top = w / 4 + w / 1.75 + 10 + 'px';
                        tips.style.left = w / 4 + w / 20 + clothImage.offsetLeft + 'px';
                        tips.style.width = w / 2.375 + 'px';
                    },
                    initTransform: function initTransform() {
                        var img = document.querySelector('.img-container');
                        var initScale = 1;
                        Transform(img);
                        var that = this;
                        var af = new _alloy_finger2.default(img, {
                            touchStart: function touchStart() {},
                            touchMove: function touchMove() {},
                            touchEnd: function touchEnd() {},
                            touchCancel: function touchCancel() {},
                            multipointStart: function multipointStart() {
                                // 缩放比例
                                initScale = img.scaleX;
                            },
                            multipointEnd: function multipointEnd() {},
                            tap: function tap() {},
                            doubleTap: function doubleTap(evt) {},
                            longTap: function longTap() {},
                            singleTap: function singleTap() {},
                            rotate: function rotate(evt) {
                                // 记录旋转角度
                                img.rotateZ = that.designData.transform.deg;
                                img.rotateZ += evt.angle;
                                that.designData.transform.deg = img.rotateZ;
                                that.imageMoveTag = true;
                            },
                            pinch: function pinch(evt) {
                                // 图片缩放比例
                                img.scaleX = img.scaleY = that.designData.transform.scale;
                                img.scaleX = img.scaleY = initScale * evt.zoom;
                                that.designData.transform.scale = document.getElementById('img').width * img.scaleX / document.getElementById('img').naturalWidth;
                                that.imageMoveTag = true;
                            },
                            pressMove: function pressMove(evt) {
                                // 记录图案中心点偏移距离
                                img.translateX = that.designData.transform.translateX;
                                img.translateY = that.designData.transform.translateY;
                                img.translateX += evt.deltaX;
                                img.translateY += evt.deltaY;
                                that.designData.transform.translateX = img.translateX;
                                that.designData.transform.translateY = img.translateY;
                                that.imageMoveTag = true;
                                evt.preventDefault();
                            },
                            swipe: function swipe(evt) {}
                        });
                    },
                    changeImageLabel: function changeImageLabel(type, label) {
                        var _this2 = this;

                        if (label != this.designData.image.label) {
                            axios.get("/index/index/get_image_by_label", {
                                params: {
                                    label: label,
                                    type: this.styleType
                                }
                            }).then(function (res) {
                                var that = _this2;
                                var num;
                                _this2.imageList = res.data;
                                _this2.page = 1;
                                _this2.maxNum = _this2.imageList.length;
                                if (_this2.maxNum % _this2.pageNum == 0) {
                                    _this2.maxPage = _this2.maxNum / _this2.pageNum;
                                } else {
                                    _this2.maxPage = (_this2.maxNum - _this2.maxNum % _this2.pageNum) / _this2.pageNum + 1;
                                }
                                _this2.imageUrlInfo = [];

                                for (num = 0; num < _this2.pageNum; num++) {
                                    _this2.imageUrlInfo.push(JSON.parse(_this2.imageList[num].image));
                                    _this2.imagePriceInfo.push(_this2.imageList[num].price);
                                    _this2.imageNameInfo.push(_this2.imageList[num].name);
                                }
                                _this2.designData.image.label = label;
                            });
                        }
                        this.designData.image.type = type;
                        this.designData.image.label = label;
                    },
                    loadMoreImage: function loadMoreImage() {
                        var num;
                        this.finished = true;
                        if (this.page > this.maxPage) {
                            return;
                        };
                        this.page += 1;
                        if (this.page < this.maxPage) {
                            for (num = this.pageNum * (this.page - 1); num < this.page * this.pageNum; num++) {
                                this.imageUrlInfo.push(JSON.parse(this.imageList[num].image));
                                this.imagePriceInfo.push(this.imageList[num].price);
                                this.imageNameInfo.push(this.imageList[num].name);
                            }
                        }
                        if (this.page == this.maxPage) {
                            for (num = this.pageNum * (this.page - 1); num < this.maxNum; num++) {
                                this.imageUrlInfo.push(JSON.parse(this.imageList[num].image));
                                this.imagePriceInfo.push(this.imageList[num].price);
                                this.imageNameInfo.push(this.imageList[num].name);
                            }
                        }
                    },
                    changeTab: function changeTab(tab) {
                        if (this.curTab === tab) {
                            this.curTab = '';
                        } else {
                            this.curTab = tab;
                        }

                        if (tab === 'style') {
                            this.styleShow = !this.styleShow;
                            this.imageShow = false;
                            this.checkShow = false;
                        }
                        if (tab === 'image') {
                            var pageTitle = document.querySelector('.page-title');
                            pageTitle.innerText = "选图案";
                            this.imageShow = !this.imageShow;
                            this.styleShow = false;
                            this.checkShow = false;
                        }
                        if (tab === 'checkout') {
                            this.createOrder();
                            this.checkShow = !this.checkShow;
                            this.styleShow = false;
                            this.imageShow = false;
                        }
                    },
                    addImage: function addImage(ev, index) {
                        //选择图案
                        this.imageTarget = ev;
                        this.imageIndex = index;
                    },
                    confirm: function confirm() {
                        var _this3 = this;

                        // 添加选择图案
                        if (this.imageTarget != "") {
                            this.imageEditTag = true;
                            var host = window.location.host;
                            var rootPath = 'http://' + host + '/uploads/';
                            this.showTag = true;
                            this.curTab = '';
                            this.imgShow = true;
                            this.imageShow = !this.imageShow;
                            var event = this.imageTarget;
                            var target = event.target;
                            var relative = target.src.replace(rootPath, ''); //图片相对路径
                            var clothImage = this.$refs.baseImage;
                            var w = clothImage.width;
                            this.imageUrl = target.src;
                            var addImage = document.getElementsByClassName('addImage')[0];
                            var tips = document.getElementsByClassName('tips')[0];
                            var imgContainer = document.getElementsByClassName('img-container')[0];
                            var imgSelected = document.getElementById('img');
                            addImage.style.width = w / 2.375 + 'px';
                            addImage.style.height = w / 1.75 + 'px';
                            addImage.style.left = w / 4 + w / 20 + clothImage.offsetLeft + 'px';
                            addImage.style.top = w / 4 + 'px';
                            tips.style.top = w / 4 + w / 1.75 + 10 + 'px';
                            tips.style.left = w / 4 + w / 20 + clothImage.offsetLeft + 'px';
                            tips.style.width = w / 2.375 + 'px';
                            this.designData.transform.locationW = w / 2.375 + 'px';
                            this.designData.transform.locationH = w / 1.75 + 'px';
                            imgContainer.style.height = imgSelected.style.height;
                            this.imageList.forEach(function (element) {
                                var b = JSON.parse(element.image).positive.replace(/\\/g, '/');
                                if (b == relative) {
                                    _this3.imagePrice = element.price;
                                    _this3.designData.image.image_id = element.id;
                                    _this3.designData.image.image_path = JSON.parse(element.image).positive;
                                    _this3.designData.image.image_name = element.name;
                                    _this3.imageName = element.name;
                                }
                            });
                            vm.$refs.addImage.onload = function () {
                                vm.designData.transform.scale = document.getElementById('img').width / document.getElementById('img').naturalWidth;
                            };
                        } else {
                            this.curTab = '';
                        }
                        var pageTitle = document.querySelector('.page-title');
                        if (this.styleType == 1) {
                            pageTitle.innerText = "数码彩喷";
                        } else {
                            pageTitle.innerText = "激光速绘";
                        }
                    },
                    style_confirm: function style_confirm() {
                        this.curTab = "";
                    },
                    getStyleParam: function getStyleParam() {
                        var _this4 = this;

                        //显示文案
                        axios.get("/index/index/get_style_param").then(function (res) {
                            _this4.styleTypeList = res.data;
                            var tmp = [],
                                tmp2 = [];
                            _this4.styleTypeList.color.forEach(function (item, index) {
                                if (vm.styleType == 1) {
                                    if (item.content == '白色' || item.content == '杏色') {
                                        tmp.push(item.id);
                                        tmp2.push(item);
                                    }
                                } else {
                                    if (item.content == '黑色' || item.content == '灰色') {
                                        tmp.push(item.id);
                                        tmp2.push(item);
                                    }
                                }
                            });

                            _this4.styleTypeList.color = tmp2;
                            _this4.colorId = tmp;
                            _this4.colorId.splice(_this4.colorId.length, 1);
                        });
                    },
                    createOrder: function createOrder() {
                        var _this5 = this;

                        if (this.creatingOrderFlag) {
                            return;
                        }

                        this.creatingOrderFlag = 1;
                        this.buyText = '正在生成';

                        axios.get( // 创建订单
                        "/index/index/create_order", {
                            params: {
                                design_id: this.designData.template_id,
                                order_info: {
                                    number: 1
                                }
                            }
                        }).then(function (res) {
                            var data = res.data;
                            if (data['code'] == "200") {
                                window.location.href = "/checkout/?order_id=" + data['data']['order_id'];
                            } else {
                                _this5.buyText = '立即生成';
                                alert(data['message']);
                            }

                            _this5.creatingOrderFlag = 0;
                        });
                    },
                    getTagList: function getTagList(item, status) {
                        var _this6 = this;

                        axios.get("/index/admin/get_tag_list").then(function (res) {
                            var data = res.data;
                            var that = _this6;
                            var tmp = [];
                            data.forEach(function (item, index) {
                                tmp.push(item.label);
                            });

                            _this6.recommendLabel = tmp;
                            _this6.changeImageLabel('system', _this6.recommendLabel[0]);
                        });
                    },
                    getStyleRemain: function getStyleRemain() {
                        var _this7 = this;

                        axios.get("/index/index/get_style_remain").then(function (res) {
                            _this7.styleRemain = res.data;
                        });
                    },
                    createTemplate: function createTemplate() {
                        var _this8 = this;

                        //保存创建模板
                        axios.get("/index/index/create_design", {
                            params: this.designData
                        }).then(function (res) {
                            var data = res.data;
                            if (data.code == '200') {
                                _this8.designData.template_id = data.data['template_id'];
                            }
                        });
                    },

                    //跳转到小程序
                    navigateToMiniProgram: function navigateToMiniProgram(param) {
                        var url = "/pages/wxPay/wxPay?payParam=" + encodeURIComponent(payParam);
                        alert('url:' + url);
                        wx.miniProgram.navigateTo({
                            url: url
                        });
                    },
                    getDesignTemplate: function getDesignTemplate() {
                        var _this9 = this;

                        // 获取模板样式
                        axios.get("/index/index/get_design_template", {
                            params: {
                                design_id: this.design_id
                            }
                        }).then(function (res) {
                            _this9.creatingDesignId = 1;
                            var that = _this9;
                            var img = document.getElementsByClassName('img-container')[0];
                            var data = res.data;
                            var style = JSON.parse(data.style);
                            var images = JSON.parse(data.image);
                            var transform = JSON.parse(data.transform);
                            _this9.designData.transform.locationW = transform.locationW; // 图案所在区域 宽高
                            _this9.designData.transform.locationH = transform.locationH;
                            _this9.designData.transform.deg = transform.deg;
                            _this9.designData.transform.scale = transform.scale; // 图案缩放比例
                            _this9.designData.transform.translateX = transform.translateX; // 中心偏移距离
                            _this9.designData.transform.translateY = transform.translateY;
                            _this9.imageName = images.iamge_name;
                            _this9.imageUrl = _this9.upload + images.image_path.replace(/\\/g, '/');
                            _this9.designData.image.type = images.type;
                            _this9.designData.image.image_id = images.image_id;
                            _this9.designData.image.image_path = images.image_path;

                            _this9.initImgLocate();
                            _this9.$refs.addImage.onload = function () {
                                that.imageEditTag = true;
                                img.style.width = document.getElementById('img').naturalWidth * transform.scale + 'px';
                                img.style.height = document.getElementById('img').naturalHeight * transform.scale + 'px';
                                img.style.transform = "rotateZ(" + transform.deg + "deg)" + "translate(" + transform.translateX + "px" + "," + transform.translateY + "px)";
                            };
                            _this9.designData.style.sex = style.sex;
                            _this9.designData.style.material = style.material;
                            _this9.designData.style.style = style.style;
                            _this9.designData.style.level = style.level;
                            _this9.designData.style.color = style.color;
                            _this9.designData.style.size = style.size;
                            _this9.imageList.forEach(function (el) {
                                if (_this9.designData.image.image_id == el.id) {
                                    _this9.imagePrice = el.price;
                                }
                            });
                            _this9.createTemplate();
                        });
                    },
                    changeDesign: function changeDesign() {
                        var _this10 = this;

                        this.styleSelect.forEach(function (el, index) {
                            if (el.sex === _this10.designData.style.sex && el.color === _this10.designData.style.color && el.style === _this10.designData.style.style && el.material === _this10.designData.style.material && _this10.designData.style.level === el.level) {
                                var size = [];
                                _this10.sizeNum = [];
                                _this10.stylePrice = _this10.styleSelect[index].price;
                                _this10.costPrice = _this10.styleSelect[index].cost;
                                if (_this10.costPrice == 0 | _this10.costPrice == 'null' | _this10.costPrice == 'undefined' | _this10.costPrice == _this10.stylePrice) {
                                    _this10.showcost = false;
                                } else if (_this10.costPrice > _this10.stylePrice) {
                                    _this10.showcost = true;
                                } else {
                                    _this10.showcost = false;
                                }
                                size.push(JSON.parse(el.rest));
                                size.forEach(function (el) {
                                    for (var key in el) {
                                        _this10.sizeNum.push(parseInt(el[key])); //货物存货数量
                                    }
                                });
                                var image = JSON.parse(el.image);
                                if (_this10.side == 'front') {
                                    _this10.styleUrl = '/uploads/' + image.positive + '?t=' + +new Date();
                                } else if (_this10.side == 'behind') {
                                    _this10.styleUrl = '/uploads/' + image.reverse + '?t=' + +new Date();
                                }
                            }
                        });
                    },
                    sizeChange: function sizeChange() {
                        var _this11 = this;

                        vm.index = []; //找到没有存货的尺寸码数
                        var len = 4,
                            pos = 0,
                            exist = [];
                        while (pos < len) {
                            pos = vm.sizeNum.indexOf(0, pos);
                            if (pos === -1) {
                                //未找到就退出循环完成搜索
                                break;
                            }
                            vm.index.push(pos); //找到就存储索引
                            pos += 1; //并从下个位置开始搜索
                        }
                        vm.index.forEach(function (el) {
                            vm.stock.cloth_size.push(vm.sizeNames[el]);
                        });
                        this.sizeList.forEach(function (el, index) {
                            if (_this11.stock.cloth_size.indexOf(el.name) == -1) {
                                exist.push(index);
                            }
                        });
                        this.designData.style.size = this.sizeNames[exist[0]];
                    },
                    judgeStyle: function judgeStyle() {
                        var _this12 = this;

                        this.styleSelect.forEach(function (el, index) {
                            if (_this12.stock.sex.indexOf(1) != -1 && el.sex == 1) {
                                _this12.designData.style.sex = el.sex;
                                _this12.stock.color.push(el.color);
                                if (_this12.stock.color.indexOf(3) != -1 && el.color == 3) {
                                    _this12.designData.style.color = el.color;
                                    _this12.stock.style.push(el.style);

                                    if (_this12.stock.style.indexOf(5) != -1 && el.style == 5) {
                                        _this12.designData.style.style = el.style;
                                        _this12.stock.material.push(el.material);

                                        if (_this12.stock.material.indexOf(7) != -1 && el.material == 7) {
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);

                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        } else if (_this12.stock.material.indexOf(7) == -1) {
                                            _this12.designData.style.material = el.material;
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        }
                                    } else if (_this12.stock.style.indexOf(5) == -1) {
                                        _this12.designData.style.style = el.style;
                                        _this12.stock.material.push(el.material);
                                        if (_this12.stock.material.indexOf(7) != -1 && el.material == 7) {
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        } else if (_this12.stock.material.indexOf(7) == -1) {
                                            _this12.designData.style.material = el.material;
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        }
                                    }
                                } else if (_this12.stock.color.indexOf(3) == -1) {
                                    _this12.designData.style.color = el.color;
                                    _this12.stock.style.push(el.style);
                                    if (_this12.stock.style.indexOf(5) != -1 && el.style == 5) {
                                        _this12.designData.style.style = el.style;
                                        _this12.stock.material.push(el.material);
                                        if (_this12.stock.material.indexOf(7) != -1 && el.material == 7) {
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        } else if (_this12.stock.material.indexOf(7) == -1) {
                                            _this12.designData.style.material = el.material;
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        }
                                    } else if (_this12.stock.style.indexOf(5) == -1) {
                                        _this12.designData.style.style = el.style;
                                        _this12.stock.material.push(el.material);
                                        if (_this12.stock.material.indexOf(7) != -1 && el.material == 7) {
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        } else if (_this12.stock.material.indexOf(7) == -1) {
                                            _this12.designData.style.material = el.material;
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        }
                                    }
                                }
                            } else if (_this12.stock.sex.indexOf(1) == -1) {
                                _this12.designData.style.sex = el.sex;
                                _this12.stock.color.push(el.color);
                                if (_this12.stock.color.indexOf(3) != -1 && el.color == 3) {
                                    _this12.designData.style.color = el.color;
                                    _this12.stock.style.push(el.style);
                                    if (_this12.stock.style.indexOf(5) != -1 && el.style == 5) {
                                        _this12.designData.style.style = el.style;
                                        _this12.stock.material.push(el.material);
                                        if (_this12.stock.material.indexOf(7) != -1 && el.material == 7) {
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        } else if (_this12.stock.material.indexOf(7) == -1) {
                                            _this12.designData.style.material = el.material;
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        }
                                    } else if (_this12.stock.style.indexOf(5) == -1) {
                                        _this12.designData.style.style = el.style;
                                        _this12.stock.material.push(el.material);
                                        if (_this12.stock.material.indexOf(7) != -1 && el.material == 7) {
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        } else if (_this12.stock.material.indexOf(7) == -1) {
                                            _this12.designData.style.material = el.material;
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        }
                                    }
                                } else if (_this12.stock.color.indexOf(3) == -1) {
                                    _this12.designData.style.color = el.color;
                                    _this12.stock.style.push(el.style);
                                    if (_this12.stock.style.indexOf(5) != -1 && el.style == 5) {
                                        _this12.designData.style.style = el.style;
                                        _this12.stock.material.push(el.material);
                                        if (_this12.stock.material.indexOf(7) != -1 && el.material == 7) {
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        } else if (_this12.stock.material.indexOf(7) == -1) {
                                            _this12.designData.style.material = el.material;
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        }
                                    } else if (_this12.stock.style.indexOf(5) == -1) {
                                        _this12.designData.style.style = el.style;
                                        _this12.stock.material.push(el.material);
                                        if (_this12.stock.material.indexOf(7) != -1 && el.material == 7) {
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        } else if (_this12.stock.material.indexOf(7) == -1) {
                                            _this12.designData.style.material = el.material;
                                            _this12.designData.style.material = el.material;
                                            _this12.stock.level.push(el.level);
                                            if (_this12.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                _this12.designData.style.level = el.level;
                                            } else if (_this12.stock.level.indexOf(11) == -1) {
                                                _this12.designData.style.level = el.level;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    },
                    showMain: function showMain() {
                        if (this.main == true) {
                            return;
                        } else {
                            this.main = true;
                            this.changeSide('front');
                        }
                    },
                    showReverse: function showReverse() {
                        if (this.main == false) {
                            return;
                        } else {
                            this.main = false;
                            this.changeSide('behind');
                        }
                    }
                },
                computed: {
                    totalPrice: function totalPrice() {
                        return this.stylePrice + this.imagePrice;
                    }
                },
                watch: {
                    designData: {
                        handler: _.throttle(function (event) {
                            if (vm.creatingDesignId == 1) {
                                vm.createTemplate();
                            }
                            vm.changeDesign();
                        }, 1000),
                        deep: true
                    },
                    'designData.style.sex': {
                        handler: _.throttle(function (event) {
                            vm.stock.color = [];
                            vm.stock.style = [];
                            vm.stock.material = [];
                            vm.stock.level = [];
                            vm.stock.cloth_size = [];
                            vm.styleSelect.forEach(function (el) {
                                if (el.sex == vm.designData.style.sex) {
                                    vm.stock.color.push(el.color);
                                    if (vm.stock.color.indexOf(3) != -1 && el.color == 3) {
                                        vm.designData.style.color = el.color;
                                        vm.stock.style.push(el.style);
                                        if (vm.stock.style.indexOf(5) != -1 && el.style == 5) {
                                            vm.designData.style.style = el.style;
                                            vm.stock.material.push(el.material);
                                            if (vm.stock.material.indexOf(7) != -1 && el.material == 7) {
                                                vm.designData.style.material = el.material;
                                                vm.stock.level.push(el.level);
                                                if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                    vm.designData.style.level = el.level;
                                                } else if (vm.stock.level.indexOf(11) == -1) {
                                                    vm.designData.style.level = el.level;
                                                }
                                            } else if (vm.stock.material.indexOf(7) == -1) {
                                                vm.designData.style.material = el.material;
                                                vm.stock.level.push(el.level);
                                                if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                    vm.designData.style.level = el.level;
                                                } else if (vm.stock.level.indexOf(11) == -1) {
                                                    vm.designData.style.level = el.level;
                                                }
                                            }
                                        } else if (vm.stock.style.indexOf(5) == -1) {
                                            vm.designData.style.style = el.style;
                                            vm.stock.material.push(el.material);
                                            if (vm.stock.material.indexOf(7) != -1 && el.material == 7) {
                                                vm.designData.style.material = el.material;
                                                vm.stock.level.push(el.level);
                                                if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                    vm.designData.style.level = el.level;
                                                } else if (vm.stock.level.indexOf(11) == -1) {
                                                    vm.designData.style.level = el.level;
                                                }
                                            } else if (vm.stock.material.indexOf(7) == -1) {
                                                vm.designData.style.material = el.material;
                                                vm.stock.level.push(el.level);
                                                if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                    vm.designData.style.level = el.level;
                                                } else if (vm.stock.level.indexOf(11) == -1) {
                                                    vm.designData.style.level = el.level;
                                                }
                                            }
                                        }
                                    } else if (vm.stock.color.indexOf(3) == -1) {
                                        vm.designData.style.color = el.color;
                                        vm.stock.style.push(el.style);
                                        if (vm.stock.style.indexOf(5) != -1 && el.style == 5) {
                                            vm.designData.style.style = el.style;
                                            vm.stock.material.push(el.material);
                                            if (vm.stock.material.indexOf(7) != -1 && el.material == 7) {
                                                vm.designData.style.material = el.material;
                                                vm.stock.level.push(el.level);
                                                if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                    vm.designData.style.level = el.level;
                                                } else if (vm.stock.level.indexOf(11) == -1) {
                                                    vm.designData.style.level = el.level;
                                                }
                                            } else if (vm.stock.material.indexOf(7) == -1) {
                                                vm.designData.style.material = el.material;
                                                vm.stock.level.push(el.level);
                                                if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                    vm.designData.style.level = el.level;
                                                } else if (vm.stock.level.indexOf(11) == -1) {
                                                    vm.designData.style.level = el.level;
                                                }
                                            }
                                        } else if (vm.stock.style.indexOf(5) == -1) {
                                            vm.designData.style.style = el.style;
                                            vm.stock.material.push(el.material);
                                            if (vm.stock.material.indexOf(7) != -1 && el.material == 7) {
                                                vm.designData.style.material = el.material;
                                                vm.stock.level.push(el.level);
                                                if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                    vm.designData.style.level = el.level;
                                                } else if (vm.stock.level.indexOf(11) == -1) {
                                                    vm.designData.style.level = el.level;
                                                }
                                            } else if (vm.stock.material.indexOf(7) == -1) {
                                                vm.designData.style.material = el.material;
                                                vm.stock.level.push(el.level);
                                                if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                    vm.designData.style.level = el.level;
                                                } else if (vm.stock.level.indexOf(11) == -1) {
                                                    vm.designData.style.level = el.level;
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                            vm.changeDesign();
                            vm.sizeChange();
                        }, 1000)
                        // deep: true
                    },
                    'designData.style.color': {
                        handler: _.throttle(function (event) {
                            vm.stock.style = [];
                            vm.stock.material = [];
                            vm.stock.level = [];
                            vm.stock.cloth_size = [];
                            vm.styleSelect.forEach(function (el) {
                                if (el.sex == vm.designData.style.sex && el.color == vm.designData.style.color) {
                                    vm.stock.style.push(el.style);
                                    if (vm.stock.style.indexOf(5) != -1 && el.style == 5) {
                                        vm.designData.style.style = el.style;
                                        vm.stock.material.push(el.material);

                                        if (vm.stock.material.indexOf(7) != -1 && el.material == 7) {
                                            vm.designData.style.material = el.material;
                                            vm.stock.level.push(el.level);

                                            if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                vm.designData.style.level = el.level;
                                            } else if (vm.stock.level.indexOf(11) == -1) {
                                                vm.designData.style.level = el.level;
                                            }
                                        } else if (vm.stock.material.indexOf(7) == -1) {
                                            vm.designData.style.material = el.material;
                                            vm.stock.level.push(el.level);
                                            if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                vm.designData.style.level = el.level;
                                            } else if (vm.stock.level.indexOf(11) == -1) {
                                                vm.designData.style.level = el.level;
                                            }
                                        }
                                    } else if (vm.stock.style.indexOf(5) == -1) {
                                        vm.designData.style.style = el.style;
                                        vm.stock.material.push(el.material);
                                        if (vm.stock.material.indexOf(7) != -1 && el.material == 7) {
                                            vm.designData.style.material = el.material;
                                            vm.stock.level.push(el.level);
                                            if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                vm.designData.style.level = el.level;
                                            } else if (vm.stock.level.indexOf(11) == -1) {
                                                vm.designData.style.level = el.level;
                                            }
                                        } else if (vm.stock.material.indexOf(7) == -1) {
                                            vm.designData.style.material = el.material;
                                            vm.stock.level.push(el.level);
                                            if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                                vm.designData.style.level = el.level;
                                            } else if (vm.stock.level.indexOf(11) == -1) {
                                                vm.designData.style.level = el.level;
                                            }
                                        }
                                    }
                                }
                            });

                            vm.changeDesign();
                            vm.sizeChange();
                        }, 1000)
                        // deep: true
                    },
                    'designData.style.style': {
                        handler: _.throttle(function (event) {
                            vm.stock.material = [];
                            vm.stock.level = [];
                            vm.stock.cloth_size = [];
                            vm.styleSelect.forEach(function (el) {
                                if (el.sex == vm.designData.style.sex && el.color == vm.designData.style.color && el.style == vm.designData.style.style) {
                                    vm.stock.material.push(el.material);
                                    if (vm.stock.material.indexOf(7) != -1 && el.material == 7) {
                                        vm.designData.style.material = el.material;
                                        vm.stock.level.push(el.level);
                                        if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                            vm.designData.style.level = el.level;
                                        } else if (vm.stock.level.indexOf(11) == -1) {
                                            vm.designData.style.level = el.level;
                                        }
                                    } else if (vm.stock.material.indexOf(7) == -1) {
                                        vm.designData.style.material = el.material;
                                        vm.stock.level.push(el.level);
                                        if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                            vm.designData.style.level = el.level;
                                        } else if (vm.stock.level.indexOf(11) == -1) {
                                            vm.designData.style.level = el.level;
                                        }
                                    }
                                }
                            });
                            vm.changeDesign();
                            vm.sizeChange();
                        }, 1000)
                        // deep: true
                    },
                    'designData.style.material': {
                        handler: _.throttle(function (event) {
                            vm.stock.level = [];
                            vm.stock.cloth_size = [];
                            vm.styleSelect.forEach(function (el) {
                                if (el.sex == vm.designData.style.sex && el.color == vm.designData.style.color && el.style == vm.designData.style.style && el.material == vm.designData.style.material) {
                                    vm.stock.level.push(el.level);
                                    if (vm.stock.level.indexOf(11) != -1 && el.level == 11) {
                                        vm.designData.style.level = el.level;
                                    } else if (vm.stock.level.indexOf(11) == -1) {
                                        vm.designData.style.level = el.level;
                                    }
                                }
                            });
                            vm.changeDesign();
                            vm.sizeChange();
                        }, 1000)
                        // deep: true
                    },
                    'designData.style.level': {
                        handler: _.throttle(function (event) {
                            vm.stock.cloth_size = [];
                            vm.changeDesign();
                            vm.sizeChange();
                        }, 1000)
                        // deep: true
                    },
                    side: {
                        handler: function handler(event) {
                            var _this13 = this;

                            this.styleSelect.forEach(function (el, index) {
                                if (el.sex === _this13.designData.style.sex && el.color === _this13.designData.style.color && el.style === _this13.designData.style.style && el.material === _this13.designData.style.material) {
                                    var image = JSON.parse(el.image);
                                    if (_this13.side == 'front') {
                                        _this13.styleUrl = '/uploads/' + image.positive + '?t=' + +new Date();
                                    } else if (_this13.side == 'behind') {
                                        _this13.styleUrl = '/uploads/' + image.reverse + '?t=' + +new Date();
                                    }
                                }
                            });
                        },

                        deep: true
                    }
                }
            });
        }).call(this, require("B3Wh1Y"), typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_7b550ba3.js", "/");
    }, { "B3Wh1Y": 4, "alloyfinger/alloy_finger": 5, "alloyfinger/transformjs/transform.js": 6, "alloyfinger/vue/alloy_finger.vue": 7, "buffer": 1 }] }, {}, [8]);